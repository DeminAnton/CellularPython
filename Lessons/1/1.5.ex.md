### Практика

<details>
<summary>Задание 1</summary>
В далекой-далекой галактике Федерация ведет ожесточенную войну с клингонами. Звездолеты Федерации оснащены мощными фазерами, а клингонские корабли – смертоносными фотонными торпедами. Обе стороны разработали усовершенствованные варп-двигатели для перемещения со сверхсветовой скоростью, и оборудовали свои корабли системами самоуничтожения на случай чрезвычайной ситуации.

Для игры, посвященной этой войне, нужно создать абстрактный класс `Starship` с методами `warp_speed()`, `fire_weapon()` и `self_destruct()`. Кроме того, нужно создать два подкласса `FederationStarship` и `KlingonWarship`, которые наследуют абстрактные методы `Starship` и реализуют свои собственные версии методов `warp_speed()`, `fire_weapon()` и `self_destruct()`.

Пример использования:
```python
enterprise = FederationStarship()
bird_of_prey = KlingonWarship()

enterprise.warp_speed()
bird_of_prey.warp_speed()

enterprise.fire_weapon()
bird_of_prey.fire_weapon()

enterprise.self_destruct()
bird_of_prey.self_destruct()
```
Вывод:
```plaintext
Включить варп-двигатели!
Включить маскировочное устройство!
Выпустить фотонные торпеды!
Стрелять из фазеров!
Запускаю систему самоуничтожения...
Запускаю протокол самоуничтожения...
```
</details>

<details>
<summary>Задание 2</summary>
Для ПО ресторана нужно разработать модуль, помогающий контролировать использование фруктов и овощей на кухне. Создайте абстрактный класс `Ingredient` с методами `get_name()` и `get_quantity()`. Затем создайте два подкласса `Vegetable` и `Fruit`, которые наследуют абстрактные методы от `Ingredient` и реализуют свои собственные версии методов `get_name()` и `get_quantity()`.

Пример использования:
```python
carrot = Vegetable("Морковь", 5)
apple = Fruit("Яблоки", 10)

print(carrot.get_name())
print(carrot.get_quantity())

print(apple.get_name())
print(apple.get_quantity())
```
Вывод:
```plaintext
Морковь
5 кг
Яблоки
10 кг
```
</details>

<details>
<summary>Задание 3</summary>
Для военной стратегии необходимо создать абстрактный класс `Soldier`. Каждый солдат должен уметь двигаться, защищаться и атаковать, поэтому `Soldier` имеет три абстрактных метода: `move()`, `attack()` и `defend()`. Два конкретных класса, `Infantry` (пехота) и `Cavalry` (кавалерия), будут наследовать и реализовывать эти методы. В игре также должен быть класс `Army`, который будет добавлять солдат в армию и выполнять операции атаки и защиты.

Чтобы гарантировать, что используются только экземпляры класса `Soldier`, нужно создать декоратор `validate_soldier`, который будет проверять тип объекта. Если объект не является экземпляром класса `Soldier`, декоратор выдаст ошибку `TypeError`. Декоратор будет применяться к методам `move()`, `attack()` и `defend()` классов `Infantry` и `Cavalry`.

Пример использования:
```python
army = Army()
army.add_soldier(Infantry())
army.add_soldier(Cavalry())
army.add_soldier(Infantry())
army.add_soldier(Cavalry())

army.attack()
army.defend()
```
Вывод:
```plaintext
Пехота передвигается в пешем порядке
Пехота участвует в ближнем бою
Кавалерия передвигается верхом
Кавалерия переходит в атаку
Пехота передвигается в пешем порядке
Пехота участвует в ближнем бою
Кавалерия передвигается верхом
Кавалерия переходит в атаку
Пехота передвигается в пешем порядке
Пехота держит строй
Кавалерия передвигается верхом
Кавалерия защищает фланги
Пехота передвигается в пешем порядке
Пехота держит строй
Кавалерия передвигается верхом
Кавалерия защищает фланги
```
</details>

<details>
<summary>Задание 4</summary>
Палеонтологам, работающим в заповеднике для динозавров, понадобилось ПО для отслеживания множества травоядных и плотоядных подопечных. Данные, которые нужно учитывать по каждому динозавру – имя, вид, рост, вес и рацион питания.

Создайте абстрактный класс `Dinosaur` с методами `get_personal_name()`, `get_breed()`, `get_height()`, `get_weight()` и `get_diet()`. Затем создайте два подкласса `Carnivore` (плотоядный) и `Herbivore` (травоядный), которые наследуют методы `Dinosaur` и реализуют свои собственные версии `get_personal_name()`, `get_breed()`, `get_height()`, `get_weight()` и `get_diet()`. Кроме того, создайте класс `DinosaurPark`, который содержит список динозавров и имеет методы `list_dinosaurs()`, `list_carnivores()` и `list_herbivores()` для вывода списков a) всех динозавров, b) плотоядных и c) травоядных особей.

Пример использования:
```python
t_rex = Carnivore('Тираннозавр', 'Рекс', 4800, 560)
velociraptor = Carnivore('Велоцираптор', 'Зубастик', 30, 70)
stegosaurus = Herbivore('Стегозавр', 'Стегга', 7100, 420)
triceratops = Herbivore('Трицератопс', 'Трипси', 8000, 290)

park = DinosaurPark()

park.add_dinosaur(t_rex)
park.add_dinosaur(velociraptor)
park.add_dinosaur(stegosaurus)
park.add_dinosaur(triceratops)

for dinosaur in park.list_dinosaurs():
    print(f'Имя: {dinosaur[0]}\n'
          f'Вид: {dinosaur[1]}\n'
          f'Вес: {dinosaur[2]} кг\n'
          f'Рост: {dinosaur[3]} см\n'
          f'Рацион: {dinosaur[4]}\n')
```
Вывод:
```plaintext
Имя: Рекс
Вид: Тираннозавр
Вес: 4800 кг
Рост: 560 см
Рацион: Плотоядный

Имя: Зубастик
Вид: Велоцираптор
Вес: 30 кг
Рост: 70 см
Рацион: Плотоядный

Имя: Стегга
Вид: Стегозавр
Вес: 7100 кг
Рост: 420 см
Рацион: Травоядный

Имя: Трипси
Вид: Трицератопс
Вес: 8000 кг
Рост: 290 см
Рацион: Травоядный
```
</details>

<details>
<summary>Задание 5</summary>
Для учета музыкальных инструментов в оркестре нужно создать абстрактный класс `Instrument` с методами `get_name()`, `get_type()`, `get_sound()` и `play()`. Два подкласса `StringedInstrument` (струнные) и `PercussionInstrument` (ударные) наследуют методы `Instrument` и реализуют свои собственные версии методов `get_name()`, `get_type()`, `get_sound()` и `play()`. Кроме того, необходимо реализовать класс `Orchestra`: он добавляет новые инструменты и имеет методы `list_instruments()`, `list_stringed_instruments()`, `list_percussion_instruments()`, которые выводят списки a) всех инструментов, b) ударных, c) струнных.

Пример использования:
```python
chello = StringedInstrument("виолончель", "струнный инструмент", "Strum")
maracas = PercussionInstrument("маракасы", "ударный инструмент", "Maracas")
violin = StringedInstrument("скрипка", "струнный инструмент", "Virtuoso")
drums = PercussionInstrument("барабан", "ударный инструмент", "Beat")

orchestra = Orchestra()
orchestra.add_instrument(chello)
orchestra.add_instrument(maracas)
orchestra.add_instrument(violin)
orchestra.add_instrument(drums)

print("В оркестрe есть инструменты:", ', '.join(orchestra.list_instruments()))  
print("Струнные инструменты:", ', '.join(orchestra.list_stringed_instruments())) 
print("Ударные инструменты:", ', '.join(orchestra.list_percussion_instruments()))  

print(chello.play())    
print(drums.play

())
```
Вывод:
```plaintext
В оркестрe есть инструменты: виолончель, маракасы, скрипка, барабан
Струнные инструменты: виолончель, скрипка
Ударные инструменты: маракасы, барабан
Звучит струнный инструмент виолончель
Звучит ударный инструмент барабан
```
</details>

<details>
<summary>Задание 6</summary>
Напишите класс `FilmCatalogue` (каталог фильмов), который отвечает за ведение фильмотеки. `FilmCatalogue` должен поддерживать различные типы кинокартин, чтобы пользователи могли искать фильмы по определенному жанру. Для этого необходимо создать новые классы для различных жанров (например, `Horror`, `Action`, `Romance`), которые наследуют класс `Movie` и переопределяют метод `play()` для вывода информации о том, к какому жанру относится фильм.

Пример использования:
```python
my_catalogue = FilmCatalogue()

my_catalogue.add_movie(Drama("Крестный отец", "Френсис Ф. Коппола"))
my_catalogue.add_movie(Comedy("Ночные игры", "Джон Фрэнсис Дейли, Джонатан М. Голдштейн"))
my_catalogue.add_movie(Horror("Дракула Брэма Стокера", "Френсис Ф. Коппола"))
my_catalogue.add_movie(Action("Крушение", "Жан-Франсуа Рише"))
my_catalogue.add_movie(Romance("Честная куртизанка", "Маршалл Херсковиц"))

my_catalogue.play_all_movies()

print(f"\nНайдены фильмы ужасов:")
for movie in my_catalogue.search_movies_by_genre(Horror):
    print(movie.title)

print(f"\nЗапускаем фильм из жанра 'Мелодрамы':")
my_catalogue.play_movies_by_genre(Romance)
```
Вывод:
```plaintext
Включаем драму 'Крестный отец' реж. Френсис Ф. Коппола.
Включаем комедию 'Ночные игры' реж. Джон Фрэнсис Дейли, Джонатан М. Голдштейн.
Включаем фильм ужасов 'Дракула Брэма Стокера' реж. Френсис Ф. Коппола.
Включаем боевик 'Крушение' реж. Жан-Франсуа Рише.
Включаем мелодраму 'Честная куртизанка' реж. Маршалл Херсковиц.

Найдены фильмы ужасов:
Дракула Брэма Стокера

Запускаем фильм из жанра 'Мелодрамы':
Включаем мелодраму 'Честная куртизанка' реж. Маршалл Херсковиц.
```
</details>

<details>
<summary>Задание 7</summary>
Для CRM винодельни нужно написать модуль, отвечающий за учет красных, белых и розовых вин, каждое из которых имеет свое название, сорт винограда, год и температуру подачи. Создайте базовый класс `Wine` с атрибутами `name`, `grape` и `year`. Затем создайте три подкласса `RedWine`, `WhiteWine` и `RoseWine`, которые наследуют методы и атрибуты от `Wine` и реализуют свои собственные версии метода `serve()`. Кроме того, создайте класс `Winery`, который ведет список вин и имеет метод `serve_wines()`, вызывающий метод `serve()` для каждого вина.

Пример использования:
```python
winery = Winery()
winery.add_wine(RedWine("Cabernet Sauvignon", "Каберне Совиньон", 2015))
winery.add_wine(WhiteWine("Chardonnay", "Шардоне", 2018))
winery.add_wine(RoseWine("Grenache", "Гренаш", 2020))
winery.serve_wines()
```
Вывод:
```plaintext
Красное вино 'Cabernet Sauvignon', сделанное из винограда сорта Каберне Совиньон в 2015 году, рекомендуем подавать комнатной температуры.
Белое вино 'Chardonnay', сделанное из винограда сорта Шардоне в 2018 году, рекомендуем подавать хорошо охлажденным.
Розовое вино 'Grenache', сделанное из винограда сорта Гренаш в 2020 году, рекомендуем подавать слегка охлажденным.
```
</details>

<details>
<summary>Задание 8</summary>
Для ПО аэропорта нужно разработать модуль, отслеживающий пассажирские и грузовые самолеты, которые отличаются моделью, производителем, вместимостью и грузоподъемностью. Создайте базовый класс `Aircraft` (воздушное судно) с атрибутами `model`, `manufacturer` и `capacity`. Затем создайте два подкласса `PassengerAircraft` и `CargoAircraft`, которые наследуют атрибуты и методы от `Aircraft` и реализуют свои собственные версии метода `fly()`. В дополнение создайте класс `Airport`, который содержит список самолетов и имеет метод `takeoff()`, вызывающий метод `fly()` для каждого самолета.

Пример использования:
```python
airport = Airport()
airport.add_aircraft(PassengerAircraft("Boeing 747", "Боинг", 416))
airport.add_aircraft(CargoAircraft("Airbus A330", "Эйрбас", 70))
airport.add_aircraft(PassengerAircraft("Boeing 777", "Боинг", 396))
airport.takeoff()
```
Вывод:
```plaintext
Пассажирский самолет 'Boeing 747' вместимостью 416 человек, произведенный компанией Боинг, поднимается в воздух с пассажирами на борту.
Грузовой самолет 'Airbus A330' с грузоподъемностью 70 т, произведенный компанией Эйрбас, поднимается в воздух с грузом на борту.
Пассажирский самолет 'Boeing 777' вместимостью 396 человек, произведенный компанией Боинг, поднимается в воздух с пассажирами на борту.
```
</details>

<details>
<summary>Задание 9</summary>
Необходимо реализовать модуль, отвечающий за обработку данных о тестировании конфигурации настольных компьютеров и ноутбуков, каждый из которых отличается моделью, процессором, памятью и производительностью. Создайте базовый класс `Computer` с атрибутами `model`, `processor` и `memory`. Затем создайте два подкласса `Desktop` и `Laptop`, которые наследуют атрибуты и методы `Computer` и реализуют свои собственные версии метода `run()`. В дополнение, создайте класс `ComputerStore`, который содержит список компьютеров и имеет метод `run_tests()`, вызывающий метод `run()` для каждого компьютера. Используйте декораторы для вывода результатов.

Пример использования:
```python
store = ComputerStore()
store.add_computer(Desktop("HP Legion", "Intel Core i9-10900K", "64 Гб"))
store.add_computer(Laptop("Dell Xtra", "Intel Core i5 13600K", "32 Гб"))
store.add_computer(Desktop("Lenovo SuperPad", "AMD Ryzen 7 2700X", "16 Гб"))
store.run_tests()
```
Вывод:
```plaintext
Начинаем тест производительности...
Запускаем настольный компьютер 'HP Legion' с процессором Intel Core i9-10900K и 64 Гб RAM.
Тест производительности завершен.
Начинаем тест производительности...
Запускаем ноутбук 'Dell Xtra' с процессором Intel Core i5 13600K и 32 Гб RAM.
Тест производительности завершен.
Начинаем тест производительности...
Запускаем настольный компьютер 'Lenovo SuperPad' с процессором AMD Ryzen 7 2700X и 16 Гб RAM.
Тест производительности завершен.
```
</details>

<details>
<summary>Задание 10</summary>
Определите базовый класс `Cryptocurrency`, имеющий атрибуты:

- `name` – название;
- `symbol` – символ-тикер;
- `minable` – возможность добычи майнингом;
- `rate_to_usd` – текущий курс к доллару;
- `anonymous` – наличие анонимных транзакций.

Затем создайте три подкласса `Nano`, `Iota` и `Stellar`, которые наследуют атрибуты и методы родительского класса `Cryptocurrency`, и обладают дополнительными свойствами, влияющими на размер вознаграждения за майнинг:

- атрибут `block_lattice` у `Nano`;
- `tangle` у `Iota`.

Кроме того, нужно реализовать:

- Декоратор `minable_required`, который проверяет, можно ли майнить криптовалюту перед вызовом метода `mining_reward()`, и выводит сообщение, если ее майнить нельзя.
- Функцию `print_info`, которая принимает на вход экземпляр криптовалюты и выводит информацию о монете, включая название, символ, возможность добычи, курс к доллару США, анонимность и наличие блок-решетки.

Пример использования:
```python


cryptocurrencies = [Nano(block_lattice=True, rate_to_usd=6, anonymous=False),
                    Iota(tangle=True, rate_to_usd=0.4, anonymous=False),
                    Stellar(distributed=False, rate_to_usd=0.15, anonymous=True)]

for crypto in cryptocurrencies:
    print_info(crypto)
    if crypto.minable:
        print(f"Награда за майнинг: {crypto.mining_reward()} {crypto.symbol}\n")
```
Вывод:
```plaintext
Nano (NANO): добывают майнингом, курс к USD: 6, только публичные транзакции, блок-решетка
Награда за майнинг: 0.02 NANO

Iota (IOTA): добывают майнингом, курс к USD: 0.4, только публичные транзакции
Награда за майнинг: 0.001 IOTA

Stellar (XLM): не майнится, курс к USD: 0.15, анонимные транзакции
```
</details>